<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Text Scroll with Button Transition</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden; /* No scrolling for the body */
      font-family: 'Sometype Mono', monospace;
      background-color: black;
      color: white;
      height: 100vh; /* Full view height */
    }
    canvas {
      display: block;
    }
    #button-container {
      position: absolute;
      width: 100%;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.1);  /* Start very small */
      opacity: 0.4;  /* Start darker */
    }
    #button-container button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      background-color: white;
      color: black;
      border-radius: 5px;
    }
  </style>
</head>
<body>

<div id="button-container">
  <button onclick="window.location.href='index.html'">Enter Datavisualisation</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script> <!-- Include GSAP -->

<script>
  let scene, camera, renderer;
  let textMeshes = [];
  let font;
  const distanceBetweenTexts = 30;  // Increased distance between each text along the Z-axis for more space
  const extraDistanceAfterLastText = 25; // Move the button further behind the last text
  const textData = [
    "Over 30,000 refugees drowned,\ntheir names unknown.",
    "From 2014 to 2023, millions fled war,\npoverty, and persecution, risking\ntheir lives for survival.",
    "Borders closed, compassion faded,\nand the world watched as lives were lost.\nRefugees don’t choose to flee –\nthey're forced to.",
    "In this Project we aimed to visualize this tragedy\nthrough data, hoping to raise awareness and show\nthe horror behind the numbers."
  ];

  const loader = new THREE.FontLoader();
  loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(loadedFont) {
    font = loadedFont;
    init();
  });

  function init() {
    // Create the scene
    scene = new THREE.Scene();

    // Set up the camera further back so the first text is in frame
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 40;  // Start further back to make sure the first text is fully visible

    // Set up the renderer
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create text materials and meshes
    textData.forEach((text, index) => {
      const geometry = new THREE.TextGeometry(text, {
        font: font,
        size: 1.2,  // Text size slightly increased
        height: 0.1,
        curveSegments: 12
      });

      // Set the text color to white
      const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
      const textMesh = new THREE.Mesh(geometry, material);

      textMesh.geometry.center();  // Center the text horizontally and vertically
      textMesh.position.set(0, 0, -index * distanceBetweenTexts);  // Place texts along the Z axis
      textMeshes.push(textMesh);
      scene.add(textMesh);
    });

    // Add the button's position behind the last text
    const buttonZPosition = -(textData.length * distanceBetweenTexts + extraDistanceAfterLastText);

    // Add an event listener to simulate scrolling without body scrolling
    window.addEventListener('wheel', onScroll, false);
    animate();
  }

  function onScroll(event) {
    const scrollAmount = event.deltaY * 0.03;  // Reduce scroll speed further for slower camera movement

    // Reverse the scroll direction: Scroll DOWN moves the camera backward, Scroll UP moves it forward
    camera.position.z += scrollAmount;  // Camera moves backward when scrolling down

    updateTextVisibility();
    updateButtonVisibility();
  }

  function updateTextVisibility() {
    textMeshes.forEach((mesh, index) => {
      let distance = Math.abs(camera.position.z - mesh.position.z);

      // Animate the text appearance and size based on distance to the camera
      if (distance < 25) {  // Highlight the text earlier by checking further distance
        // Animate to bright and fully opaque
        gsap.to(mesh.material, { opacity: 1, duration: 0.5 });
        gsap.to(mesh.scale, { x: 1 + (1 - distance / 25), y: 1 + (1 - distance / 25), z: 1, duration: 0.5 });
      } else {
        // Animate to transparent and default scale
        gsap.to(mesh.material, { opacity: 0.4, duration: 0.5 });
        gsap.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
      }
    });
  }

  function updateButtonVisibility() {
    const button = document.getElementById('button-container');
    const lastTextPositionZ = -(textMeshes.length - 1) * distanceBetweenTexts;
    const buttonZPosition = lastTextPositionZ - extraDistanceAfterLastText;

    let distance = Math.abs(camera.position.z - buttonZPosition);

    // Animate button like the text: darker and smaller when out of frame, fully visible and scaled up when in frame
    if (distance < 25) {
      gsap.to(button, { opacity: 1, scale: 1, duration: 0.5 });
    } else {
      gsap.to(button, { opacity: 0.4, scale: 0.1, duration: 0.5 });
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }

  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

</script>

</body>
</html>
